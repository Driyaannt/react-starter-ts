import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Function to convert folder name to route path
function folderNameToPath(name) {
  let routePath = name
    .replace(/([a-z])([A-Z])/g, '$1-$2')
    .toLowerCase();
  
  routePath = routePath.replace(/-?page$/, '');
  routePath = routePath.replace(/-+$/, '');
  
  return routePath || name.toLowerCase();
}

// Function to scan pages directory and generate routes
function generateRoutesContent() {
  const pagesDir = path.join(__dirname, '../src/pages');
  const adminDir = path.join(pagesDir, 'admin');
  const userDir = path.join(pagesDir, 'user');
  
  const adminRoutes = [];
  const userRoutes = [];
  const imports = [];
  const adminFolders = [];
  const userFolders = [];
  
  // Scan admin pages
  if (fs.existsSync(adminDir)) {
    const folders = fs.readdirSync(adminDir);
    
    folders.forEach(folder => {
      const folderPath = path.join(adminDir, folder);
      const stat = fs.statSync(folderPath);
      
      if (stat.isDirectory()) {
        const indexPath = path.join(folderPath, 'index.tsx');
        if (fs.existsSync(indexPath)) {
          const routePath = folderNameToPath(folder);
          imports.push(`import ${folder} from "@/pages/admin/${folder}";`);
          adminRoutes.push(`  { path: "${routePath}", element: <${folder} /> }`);
          adminFolders.push(folder);
        }
      }
    });
  }
  
  // Scan user pages
  if (fs.existsSync(userDir)) {
    const folders = fs.readdirSync(userDir);
    
    folders.forEach(folder => {
      const folderPath = path.join(userDir, folder);
      const stat = fs.statSync(folderPath);
      
      if (stat.isDirectory()) {
        const indexPath = path.join(folderPath, 'index.tsx');
        if (fs.existsSync(indexPath)) {
          const routePath = folderNameToPath(folder);
          imports.push(`import ${folder} from "@/pages/user/${folder}";`);
          userRoutes.push(`  { path: "/${routePath}", element: <${folder} /> }`);
          userFolders.push(folder);
        }
      }
    });
  }
  
  // Auto-generate index.ts exports for admin pages
  if (adminFolders.length > 0) {
    const adminIndexPath = path.join(adminDir, 'index.ts');
    const adminExports = [
      '// ğŸ¤– AUTO-GENERATED - DO NOT EDIT MANUALLY',
      '// Generated at: ' + new Date().toLocaleString(),
      '',
      '// Admin Pages Exports',
      ...adminFolders.map(folder => `export { default as ${folder} } from "./${folder}";`)
    ].join('\n');
    
    fs.writeFileSync(adminIndexPath, adminExports + '\n');
  }
  
  // Auto-generate index.ts exports for user pages
  if (userFolders.length > 0) {
    const userIndexPath = path.join(userDir, 'index.ts');
    const userExports = [
      '// ğŸ¤– AUTO-GENERATED - DO NOT EDIT MANUALLY',
      '// Generated at: ' + new Date().toLocaleString(),
      '',
      '// User Pages Exports',
      ...userFolders.map(folder => `export { default as ${folder} } from "./${folder}";`)
    ].join('\n');
    
    fs.writeFileSync(userIndexPath, userExports + '\n');
  }

  // Generate GENERATED_PATHS constants
  const adminPathsConst = adminFolders.map(folder => {
    const routePath = folderNameToPath(folder);
    const constName = folder.replace(/([a-z])([A-Z])/g, '$1_$2').toUpperCase();
    return `  ${constName}: buildAdminPath("${routePath}")`;
  });

  const userPathsConst = userFolders.map(folder => {
    const routePath = folderNameToPath(folder);
    const constName = folder.replace(/([a-z])([A-Z])/g, '$1_$2').toUpperCase();
    return `  ${constName}: "/${routePath}"`;
  });
  
  // Generate file content
  const content = `// ğŸ¤– THIS FILE IS AUTO-GENERATED BY VITE PLUGIN
// Do not edit manually - changes will be overwritten
// Generated at: ${new Date().toLocaleString()}

import React from "react";
${imports.join('\n')}

export interface RouteConfig {
  path: string;
  element: React.ReactElement;
}

// Admin routes (nested under /admin)
export const adminRoutes: RouteConfig[] = [
${adminRoutes.join(',\n')}
];

// User routes (top-level)
export const userRoutes: RouteConfig[] = [
${userRoutes.join(',\n')}
];

// Total routes: ${adminRoutes.length + userRoutes.length}
// Admin: ${adminRoutes.length} | User: ${userRoutes.length}

// Helper function to build full admin route paths
export const buildAdminPath = (path: string) => \`/admin/\${path}\`;

// Export paths as constants for use in other files
export const GENERATED_PATHS = {
  // Admin routes
${adminPathsConst.join(',\n')},
  
  // User routes
${userPathsConst.join(',\n')},
} as const;
`;
  
  return content;
}

// Vite plugin
export default function autoRoutesPlugin() {
  const ROUTES_FILE = path.join(__dirname, '../src/routes/generated-routes.tsx');
  const PAGES_DIR = path.join(__dirname, '../src/pages');
  
  let viteServer;
  let regenerateTimeout = null;
  
  // Debounced generate routes - prevents multiple rapid regenerations
  function debouncedGenerateRoutes(reason = 'File change') {
    if (regenerateTimeout) {
      clearTimeout(regenerateTimeout);
    }
    
    regenerateTimeout = setTimeout(() => {
      console.log(`\nğŸ”„ [Auto Routes] ${reason}`);
      generateRoutes();
    }, 150); // Wait 150ms for multiple file operations to complete
  }
  
  // Generate routes initially
  function generateRoutes() {
    try {
      const content = generateRoutesContent();
      const routesDir = path.dirname(ROUTES_FILE);
      
      if (!fs.existsSync(routesDir)) {
        fs.mkdirSync(routesDir, { recursive: true });
      }
      
      fs.writeFileSync(ROUTES_FILE, content);
      
      console.log('âœ… [Auto Routes] Routes regenerated successfully!');
      console.log(`   ğŸ“ File: ${path.relative(process.cwd(), ROUTES_FILE)}`);
      
      // Trigger HMR if server is running
      if (viteServer) {
        const module = viteServer.moduleGraph.getModuleById(ROUTES_FILE);
        if (module) {
          viteServer.moduleGraph.invalidateModule(module);
          viteServer.ws.send({
            type: 'full-reload',
            path: '*'
          });
        }
      }
    } catch (error) {
      console.error('âŒ [Auto Routes] Error generating routes:', error);
    }
  }
  
  return {
    name: 'vite-plugin-auto-routes',
    
    // Generate routes when plugin is loaded
    configResolved() {
      console.log('\nğŸš€ [Auto Routes Plugin] Activated');
      generateRoutes();
    },
    
    // Store Vite dev server instance
    configureServer(server) {
      viteServer = server;
      
      // Watch entire pages directory recursively
      const pagesAdminDir = path.join(PAGES_DIR, 'admin');
      const pagesUserDir = path.join(PAGES_DIR, 'user');
      
      // Add watchers for both directories
      if (fs.existsSync(pagesAdminDir)) {
        server.watcher.add(path.join(pagesAdminDir, '**/*'));
      }
      if (fs.existsSync(pagesUserDir)) {
        server.watcher.add(path.join(pagesUserDir, '**/*'));
      }
      
      // Additionally, set up a polling interval as fallback (every 2 seconds)
      let lastRouteState = null;
      
      function checkForChanges() {
        try {
          // Get current folders with index.tsx
          const adminFolders = fs.existsSync(pagesAdminDir) 
            ? fs.readdirSync(pagesAdminDir)
                .filter(f => {
                  const p = path.join(pagesAdminDir, f);
                  return fs.statSync(p).isDirectory() && fs.existsSync(path.join(p, 'index.tsx'));
                })
            : [];
          
          const userFolders = fs.existsSync(pagesUserDir)
            ? fs.readdirSync(pagesUserDir)
                .filter(f => {
                  const p = path.join(pagesUserDir, f);
                  return fs.statSync(p).isDirectory() && fs.existsSync(path.join(p, 'index.tsx'));
                })
            : [];
          
          const currentState = JSON.stringify({ admin: adminFolders.sort(), user: userFolders.sort() });
          
          if (lastRouteState === null) {
            lastRouteState = currentState;
          } else if (lastRouteState !== currentState) {
            console.log('\nğŸ” [Auto Routes] Detected changes via polling');
            lastRouteState = currentState;
            debouncedGenerateRoutes('Polling detected changes');
          }
        } catch (error) {
          // Silently ignore errors in polling
        }
      }
      
      // Poll every 2 seconds
      const pollingInterval = setInterval(checkForChanges, 2000);
      
      // Clean up on server close
      server.httpServer?.on('close', () => {
        clearInterval(pollingInterval);
      });
      
      // Watch for new index.tsx files
      server.watcher.on('add', (file) => {
        const normalizedFile = file.replace(/\\/g, '/');
        if ((normalizedFile.includes('/pages/admin/') || normalizedFile.includes('/pages/user/')) 
            && normalizedFile.endsWith('/index.tsx')) {
          const folderName = path.basename(path.dirname(file));
          console.log(`\nğŸ“„ [Auto Routes] New page detected: ${folderName}`);
          debouncedGenerateRoutes(`New page: ${folderName}`);
        }
      });
      
      // Watch for deleted index.tsx files
      server.watcher.on('unlink', (file) => {
        const normalizedFile = file.replace(/\\/g, '/');
        if ((normalizedFile.includes('/pages/admin/') || normalizedFile.includes('/pages/user/')) 
            && normalizedFile.endsWith('/index.tsx')) {
          const folderName = path.basename(path.dirname(file));
          console.log(`\nğŸ—‘ï¸  [Auto Routes] Page deleted: ${folderName}`);
          debouncedGenerateRoutes(`Deleted page: ${folderName}`);
        }
      });
      
      // Watch for file changes (content updates)
      server.watcher.on('change', (file) => {
        const normalizedFile = file.replace(/\\/g, '/');
        if ((normalizedFile.includes('/pages/admin/') || normalizedFile.includes('/pages/user/')) 
            && normalizedFile.endsWith('/index.tsx')) {
          const folderName = path.basename(path.dirname(file));
          // Regenerate on content change (in case component name changed)
          debouncedGenerateRoutes(`Updated page: ${folderName}`);
        }
      });
      
      // Watch for new directories
      server.watcher.on('addDir', (dir) => {
        const normalizedDir = dir.replace(/\\/g, '/');
        if (normalizedDir.includes('/pages/admin/') || normalizedDir.includes('/pages/user/')) {
          const folderName = path.basename(dir);
          // Check if index.tsx exists after a short delay (in case it's being created)
          setTimeout(() => {
            const indexPath = path.join(dir, 'index.tsx');
            if (fs.existsSync(indexPath)) {
              console.log(`\nğŸ“ [Auto Routes] New folder detected: ${folderName}`);
              debouncedGenerateRoutes(`New folder: ${folderName}`);
            }
          }, 200);
        }
      });
      
      // Watch for deleted directories
      server.watcher.on('unlinkDir', (dir) => {
        const normalizedDir = dir.replace(/\\/g, '/');
        if (normalizedDir.includes('/pages/admin/') || normalizedDir.includes('/pages/user/')) {
          const folderName = path.basename(dir);
          console.log(`\nğŸ“‚ [Auto Routes] Folder deleted: ${folderName}`);
          debouncedGenerateRoutes(`Deleted folder: ${folderName}`);
        }
      });
      
      console.log('ğŸ‘€ [Auto Routes] Watching for changes in pages directory...');
      console.log('   ğŸ” Watching: src/pages/admin/**');
      console.log('   ğŸ” Watching: src/pages/user/**');
      console.log('   ğŸ”„ Polling: Every 2 seconds (fallback)');
    },
    
    // Regenerate on build
    buildStart() {
      generateRoutes();
    }
  };
}
